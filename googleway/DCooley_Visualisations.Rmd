---
title: "Googleway, Mapdeck and API keys"
output:
    html_document:
        toc: true
        toc_float: true
        number_sections: false
        theme: flatly
    md_document:
        variant: markdown_github
        number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(mapdeck)
library(googleway)
```


```{r visualisationGoogleway} 
set_key(read.dcf("~/Documents/.googleAPI", fields = "GOOGLE_MAP_KEY"), api = "map")
set_key(read.dcf("~/Documents/.googleAPI", fields = "GOOGLE_API_KEY"))
set_token( read.dcf("~/Documents/.googleAPI", fields = "MAPBOX" ) )
```

The `googleway` library provides access to Google Maps API, both for creating maps, and using the mapping services such as geocoding, direction and route finding, and searching for places. 

To use any of Google Map's services you will need an [API key](https://developers.google.com/maps/documentation/javascript/get-api-key).

## Geocoding

The geocoding API will take as input an address, or search term, and return various pieces of information. For example, here we are querying the API for the three rehab centre addresses.

```{r, eval = FALSE}
rehab_addresses <- c(
  DandenongHospital = "Dandenong Hospital, Dandenong VIC 3175, Australia",
  CaseyHospital = "62-70 Kangan Dr, Berwick VIC 3806, Australia",
  KingstonHospital = "The Kingston Centre, Heatherton VIC 3202, Australia"
  )

RehabLocations <- lapply(rehab_addresses, googleway::google_geocode)
#saveRDS(RehabLocations, file = "../data/googleway/RehabLocations_googleway.rds")
```

```{r, eval = TRUE, echo = FALSE}
RehabLocations <- readRDS("../data/googleway/RehabLocations_googleway.rds")
```

From the results we can extract various pieces of information, such as the formatted address, the type of place, and the coordinates.

```{r}
lapply( RehabLocations, googleway::geocode_address )
lapply( RehabLocations, googleway::geocode_address_components )
lapply( RehabLocations, googleway::geocode_coordinates )

```


## 8. Estimate of travel time


We have 56,000 random addresses, and 3 rehab centres. This makes `r format( 56000 * 3, big.mark = ",")` direction queries. 

Google charges 0.005 USD per query, but gives you $200 credit each month.

Therefore, we get `r format(200 / 0.005, big.mark= ",")` queries credited per month. 

To stay within limits, and have enough spare, I'm going to sample 100 of those random addresses per postcode, and query the API for the directions from those addresses to each rehab centres. 


```{r}

## formatting the geocoded rehab centres into a data.frame
lst <- lapply( RehabLocations, function(x) {
  coords <- googleway::geocode_coordinates(x)
  data.frame(
    formatted_address = googleway::geocode_address(x),
    lat = coords[["lat"]],
    lon = coords[["lng"]]
    )
})

df_rehab <- do.call(rbind, lst)
rm(lst)
#df_rehab
```


To find the directions we need to query one route at a time. We can do this in an `lapply`. 

As this takes a while we are saving the results of each query to file at each iteration. Each result is in JSON, so we are saving the raw JSON.

```{r, echo = FALSE }

randomaddresses <- readRDS("../data/googleway/randomaddresses/randomaddresses.rds")

# df_random <- readRDS("../data/googleway/randomaddresses/df_random.rds")
```


```{r, eval = FALSE, echo = TRUE, include = TRUE}

# ## TODO - get randomaddresses from RehabCatchment
# ## need coordinates for googleway
df_random <- as.data.frame( randomaddresses )
df_random[, c("lon", "lat")] <- sf::st_coordinates( randomaddresses )

set.seed(12345)
df_sample <- df_random %>%
  dplyr::group_by(POSTCODE) %>%
  dplyr::sample_n(size = 50)


saveRDS(df_sample, "../data/googleway/directions_queries/df_sample2.rds")

res1 <- lapply(1:nrow(df_sample), function(x) {
  
  js <- googleway::google_directions(
    origin = as.numeric( df_sample[x, c("lat", "lon")] )
    , destination = as.numeric( df_rehab[1, c("lat","lon")] )
    , simplify = F
  )
  js <- paste0(js, collapse = "")
  js <- gsub(" ","",js)
  fn <- paste0("../data/googleway/directions_queries/rehab1_sample/",x,"_results.json")
  f <- file(fn)
  writeLines(js, f)
  close(f)
  return( js )
})

res2 <- lapply(1:nrow(df_sample), function(x) {
  js <- googleway::google_directions(
    origin = as.numeric( df_sample[x, c("lat", "lon")] )
    , destination = as.numeric( df_rehab[2, c("lat","lon")] )
    , simplify = F
  )
  js <- paste0(js, collapse = "")
  js <- gsub(" ","",js)
  fn <- paste0("../data/googleway/directions_queries/rehab2_sample/",x,"_results.json")
  f <- file(fn)
  writeLines(js, f)
  close(f)
  return( js )
})

res3 <- lapply(1:nrow(df_sample), function(x) {
  js <- googleway::google_directions(
    origin = as.numeric( df_sample[x, c("lat", "lon")] )
    , destination = as.numeric( df_rehab[3, c("lat","lon")] )
    , simplify = F
  )
    js <- paste0(js, collapse = "")
  js <- gsub(" ","",js)
  fn <- paste0("../data/googleway/directions_queries/rehab3_sample/",x,"_results.json")
  f <- file(fn)
  writeLines(js, f)
  close(f)
  return( js )
})

```

```{r, echo = FALSE}
df_sample <- readRDS("../data/googleway/directions_queries/df_sample2.rds")
```


Now we have all the results of the directions query saved we can read them back into the R session.

```{r, echo = TRUE, include = FALSE, eval = FALSE}

get_directions <- function(rehab) {
  path <- "~/Documents/github/GeospatialStroke/data/googleway/directions_queries"
  lst_files <- list.files(path = paste0(path, rehab) )
  files <- paste0(path, rehab, lst_files)

  lst <- lapply( files, function(x) {
    js <- jsonlite::fromJSON( x )
    bname <- basename( x )
    sample_row <- gsub("[^0-9]","",bname)
    list(sample_row = sample_row, result = js)
  })
  
  return( lst )
}

directions1 <- get_directions( "/rehab1_sample/")
directions2 <- get_directions( "/rehab2_sample/")
directions3 <- get_directions( "/rehab3_sample/")
```

```{r echo = FALSE, include = FALSE, eval = FALSE}

# ## I need to put an id onto each of the direction results, so I can use it later
# counter <- 1
# for( i in 1:length(directions1) ) {
#   directions1[[i]]$id <- counter
#   counter <- counter + 1
# }
# 
# counter <- 1
# for( i in 1:length(directions2) ) {
#   directions2[[i]]$id <- counter
#   counter <- counter + 1
# }
# 
# counter <- 1
# for( i in 1:length(directions3) ) {
#   directions3[[i]]$id <- counter
#   counter <- counter + 1
# }

saveRDS(directions1, file = "../data/googleway/directions/directions1_sample.rds")
saveRDS(directions2, file = "../data/googleway/directions/directions2_sample.rds")
saveRDS(directions3, file = "../data/googleway/directions/directions3_sample.rds")

```

```{r, echo = FALSE}
directions1 <- readRDS("../data/googleway/directions/directions1_sample.rds")
directions2 <- readRDS("../data/googleway/directions/directions2_sample.rds")
directions3 <- readRDS("../data/googleway/directions/directions3_sample.rds")
```


The route geometry returned from the API comes in the form of an [encoded polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm).  

```{r}
substr( googleway::direction_polyline( directions1[[1]][["result"]] ), 1, 100 )
```

We can convert this back into coordinates using the `googlePolylines` library, for example

```{r}
pl <- googleway::direction_polyline( directions1[[1]][["result"]] )

head( googlePolylines::decode( pl )[[1]] )
```

However, `googleway` and `mapdeck` both support plotting these polylines directly, so we can avoid this step and just use the polylines. We also get the distance and time on the routes in the API query results. 

```{r}

is_valid <- function( direction ) {
  direction[["result"]][["status"]] == "OK"
}

get_distance <- function(x) {
  ifelse(
    is_valid( x )
    , googleway::direction_legs(x[["result"]])[["distance"]][["value"]]
    , NA_real_
    )
}
get_duration <- function(x) {
  ifelse(
    is_valid( x )
    , googleway::direction_legs(x[["result"]])[["duration"]][["value"]]
    , NA_real_
    )
}

get_polyline <- function(x) {
  ifelse(
    is_valid( x )
    , googleway::direction_polyline( x[["result"]] )
    , NA_character_
  )
}

format_directions <- function( d, df_sample ) {
  secs <- sapply( d, get_duration )
  dist <- sapply( d, get_distance )
  sample_row <- sapply( d, function(x) x[["sample_row"]] )
  street <- df_sample[ sample_row, ]$STREET_NAME
  postcode <- df_sample[ sample_row, ]$POSTCODE
  polylines <- sapply( d, get_polyline )
  data.frame(
    id = sample_row
    , street = street
    , postcode = postcode
    , polyline = polylines
    , distance_m = dist
    , duration_s = secs
    , duration_m = round( secs / 60, 2 )
    , stringsAsFactors = FALSE
  )
}

df_directions1 <- format_directions( directions1, df_sample )
df_directions2 <- format_directions( directions2, df_sample )
df_directions3 <- format_directions( directions3, df_sample )


# df_directions1 <- df_directions1[ !is.na(df_directions1$polyline), ]
# df_directions2 <- df_directions2[ !is.na(df_directions2$polyline), ]
# df_directions3 <- df_directions3[ !is.na(df_directions3$polyline), ]

```

The `is_valid()` function is used to test the result of the API query. Sometimes the API will return an "ACCESS_DENIED" or "OVER_QUERY_LIMIT" response if it wasn't able to return any data. 

Now we have three data.frames, each containing the directions, distance, times and route for 10,000 random addresses to the rehab centres. 

```{r, eval = FALSE}

mapdeck(
  style = mapdeck_style("light")
  , location = c(145, -37.9)
  , zoom = 10
) %>%
  add_scatterplot(
    data = df_rehab[1, ]
    , lon = "lon", lat = "lat"
    , radius = 200
    , update_view = F
  ) %>%
  add_path(
    data = df_directions1
    , polyline = "polyline"
    , stroke_colour = "duration_m"
    , stroke_opacity = 200
    , stroke_width = 35
    , legend = T
    , legend_options = list( title = "Duration (minutes) ")
    , update_view = F
    , palette = "plasma"
  )

```

![](./directions_rehab1_sample_mapdeck.png)

We can extract the step-by-step guide, including times and locatinos, to get the 'time to destination' for each step.

```{r}
ttd <- googleway::direction_steps( directions1[[1]][["result"]] )
total_time <- get_duration( directions1[[1]][["result"]] )

## calculate time remaining at every step
ttd_duration <- ttd$duration
ttd_duration$total_time <- cumsum( ttd_duration$value )
ttd_duration$time_remaining <- total_time - ttd_duration$total_time

## get the coordinates for every step
ttd_duration <- cbind( ttd$start_location, ttd_duration )
ttd_duration
```

Doing this for each of the 8,400 directions gives us the time to the rehab centres for many points on the route, not just the origin. 

```{r}
time_to_destination <- function( direction ) {
  ttd <- googleway::direction_steps( direction[["result"]] )
  total_time <- get_duration( direction[["result"]] )

  ## calculate time remaining at every step
  ttd_duration <- ttd$duration
  ttd_duration$total_time <- cumsum( ttd_duration$value )
  ttd_duration$time_remaining <- total_time - ttd_duration$total_time
  
  ## get the coordinates for every step
  ttd_duration <- cbind( ttd$start_location, ttd_duration )
  ttd_duration
}

lst_times <- lapply( directions1, time_to_destination )
df_times1 <- do.call(rbind, lst_times)

lst_times <- lapply( directions2, time_to_destination )
df_times2 <- do.call(rbind, lst_times)

lst_times <- lapply( directions3, time_to_destination )
df_times3 <- do.call(rbind, lst_times)
```

This now gives us `r format( nrow( df_times1 ) * 3, big.mark=",")` random addresses to each of the three rehab centres. 

This plot shows the average times to `r googleway::geocode_address( RehabLocations[[1]] )` for `r nrow( df_times1 )` addresses. The height and colour of hexagons represent the average time to the rehab centre.

```{r, eval = FALSE}
mapdeck() %>%
  add_hexagon(
    data = df_times1
    , lon = "lng", lat = "lat"
    , elevation = "time_remaining"
    , elevation_function = "average"
    , colour = "time_remaining"
    , colour_function = "average"
    , elevation_scale = 10
    , radius = 250
    , colour_range = colourvalues::colour_values(1:6, palette = "plasma")
  )

```
![](./directions_rehab1_sample_mapdeck_hexagons.png)

## Distances

While the Directions API gives us a lot of information, it only handles one direction at a time. If you want more (quantity and frequency), but less detailed results, you can query the distance API.

In this example we are querying the distances for the first ten random addresses.

```{r, eval = FALSE}

distance_matrix <- googleway::google_distance(
  origin = df_sample[1:10, c("lat", "lon")]
  , destination = googleway::geocode_address( RehabLocations[[1]] )
)
```

```{r eval = FALSE, echo = FALSE}
saveRDS(distance_matrix, "../data/googleway/distances/distance_matrix.rds")
```

```{r echo = FALSE}
distance_matrix <- readRDS("../data/googleway/distances/distance_matrix.rds")
```

```{r}
distance_matrix
```


Both the distance and directions API allow you to specify the `departure_time`, so it's possible to query the time & distance for a given time of day. 


##  9. Address-based catchment basins

From Google's API results we have the driving time to each of the rehab centres for the random addresses. So we can get the nearest rehab centre for each address and view them with mapdeck


```{r}

df_directions1$rehab <- df_rehab[1, "formatted_address"]
df_directions2$rehab <- df_rehab[2, "formatted_address"]
df_directions3$rehab <- df_rehab[3, "formatted_address"]

df_directions <- rbind(
  df_directions1
  , df_directions2
  , df_directions3
)

df_nearest <- df_directions %>%
  dplyr::group_by(id) %>%
  dplyr::arrange(duration_m) %>%
  dplyr::slice(1) %>%
  dplyr::ungroup()

# #nrow(df_nearest)
# head(df_nearest)
# 
# df_nearest[ df_nearest$id == 1, ]
# df_directions[ df_directions$id == 1, c("duration_m")]

```

```{r, eval = FALSE}

mapdeck(
  style = mapdeck_style("light")
  , location = c(145.1, -37.9)
  , zoom = 10
) %>%
  add_scatterplot(
    data = df_rehab
    , lon = "lon", lat = "lat"
    , radius = 600
  ) %>%
  add_path(
    data = df_nearest
    , polyline = "polyline"
    , stroke_colour = "rehab"
    , legend = T
    , legend_options = list(css = "max-width: 300px")
    , update_view = F
  )

```
![](./nearest_rehab.png)






