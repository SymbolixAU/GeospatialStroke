---
title: "googleway and mapdeck"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(mapdeck)
library(googleway)
```


```{r visualisationGoogleway} 
set_key(read.dcf("~/Documents/.googleAPI", fields = "GOOGLE_MAP_KEY"), api = "map")
set_key(read.dcf("~/Documents/.googleAPI", fields = "GOOGLE_API_KEY"))
set_token( read.dcf("~/Documents/.googleAPI", fields = "MAPBOX" ) )
```

The `googleway` library provides access to Google Maps API, both for creating maps, and using the mapping services such as geocoding, direction and route finding, and searching for places. 

To use any of Google Map's services you will need an [API key](https://developers.google.com/maps/documentation/javascript/get-api-key).

## Geocoding

The geocoding API will take as input an address, or search term, and return various pieces of information. For example, here we are querying the API for the three rehab centre addresses.

```{r, eval = FALSE}
rehab_addresses <- c(
  DandenongHospital = "Dandenong Hospital, Dandenong VIC 3175, Australia",
  CaseyHospital = "62-70 Kangan Dr, Berwick VIC 3806, Australia",
  KingstonHospital = "The Kingston Centre, Heatherton VIC 3202, Australia"
  )

RehabLocations <- lapply(rehab_addresses, googleway::google_geocode)
#saveRDS(RehabLocations, file = "../data/googleway/RehabLocations_googleway.rds")
```

```{r, eval = TRUE, echo = FALSE}
RehabLocations <- readRDS("../data/googleway/RehabLocations_googleway.rds")
```

From the results we can extract various pieces of information, such as the formatted address, the type of place, and the coordinates.

```{r}
lapply( RehabLocations, googleway::geocode_address )
lapply( RehabLocations, googleway::geocode_address_components )
lapply( RehabLocations, googleway::geocode_coordinates )

```


## Directions


We have 56,000 random addresses, and 3 rehab centres. This makes `r format( 56000 * 3, big.mark = ",")` direction queries. 

Google charges 0.005 USD per query, but gives you $200 credit each month.

Therefore, we get `r format(200 / 0.005, big.mark= ",")` queries credited per month. 

To stay within limits, and have enough spare, I'm going to sample 10,000 of those random addresses for each rehab centre, and query the API for the directions from those addresses to the rehab centres. 


```{r}

## formatting the geocoded rehab centres into a data.frame
lst <- lapply( RehabLocations, function(x) {
  coords <- googleway::geocode_coordinates(x)
  data.frame(
    formatted_address = googleway::geocode_address(x),
    lat = coords[["lat"]],
    lon = coords[["lng"]]
    )
})

df_rehab <- do.call(rbind, lst)
rm(lst)
#df_rehab
```


To find the directions we need to query one route at a time. We can do this in an `lapply`. 

As this takes a while we are saving the results of each query to file at each iteration. Each result is in JSON, so we are saving the raw JSON.

```{r, echo = FALSE }

df_random <- readRDS("../data/googleway/randomaddresses/df_random.rds")
```


```{r, eval = FALSE, echo = TRUE, include = TRUE}

# ## TODO - get randomaddresses from RehabCatchment
# ## need coordinates for googleway
# df_random <- as.data.frame( randomaddresses )
# df_random[, c("lon", "lat")] <- sf::st_coordinates( randomaddresses )


set.seed(12345)
r <- 1:nrow(df)
r <- sample(r, size = 10000)

res1 <- lapply(r, function(x) {
  
  js <- googleway::google_directions(
    origin = as.numeric( df_random[x, c("lat", "lon")] )
    , destination = as.numeric( sf::st_coordinates( RehabLocations[1, "geometry"] )[, c("Y","X")] )
    , simplify = F
  )
  js <- paste0(js, collapse = "")
  js <- gsub(" ","",js)
  fn <- paste0("../data/googleway/directions_queries/rehab1/",x,"_results.json")
  f <- file(fn)
  writeLines(js, f)
  close(f)
  return( js )
})

res2 <- lapply(r, function(x) {
  js <- googleway::google_directions(
    origin = as.numeric( df_random[x, c("lat", "lon")] )
    , destination = as.numeric( sf::st_coordinates( RehabLocations[2, "geometry"] )[, c("Y","X")] )
  )
  js <- paste0(js, collapse = "")
  js <- gsub(" ","",js)
  fn <- paste0("../data/googleway/directions_queries/rehab2/",x,"_results.json")
  f <- file(fn)
  writeLines(js, f)
  close(f)
  return( js )
})

res3 <- lapply(r, function(x) {
  js <- googleway::google_directions(
    origin = as.numeric( df_random[x, c("lat", "lon")] )
    , destination = as.numeric( sf::st_coordinates( RehabLocations[3, "geometry"] )[, c("Y","X")] )
  )
    js <- paste0(js, collapse = "")
  js <- gsub(" ","",js)
  fn <- paste0("../data/googleway/directions_queries/rehab3/",x,"_results.json")
  f <- file(fn)
  writeLines(js, f)
  close(f)
  return( js )
})

```

Now we have all the results of the directions query saved we can read them back into the R session

```{r, echo = TRUE, include = FALSE, eval = FALSE}

get_directions <- function(rehab) {
  path <- "~/Documents/github/GeospatialStroke/data/googleway/directions_queries"
  lst_files <- list.files(path = paste0(path, "/rehab1/") )
  files <- paste0(path, "/rehab1/", lst_files)

  return(
    lapply( files, jsonlite::fromJSON )
  )
}

directions1 <- get_directions( "/rehab1/")
directions2 <- get_directions( "/rehab2/")
directions3 <- get_directions( "/rehab3/")
```

```{r echo = FALSE, include = FALSE, eval = FALSE}
saveRDS(directions1, file = "../data/googleway/directions/directions1.rds")
saveRDS(directions2, file = "../data/googleway/directions/directions2.rds")
saveRDS(directions3, file = "../data/googleway/directions/directions3.rds")

```

```{r, echo = FALSE}
directions1 <- readRDS("../data/googleway/directions/directions1.rds")
directions2 <- readRDS("../data/googleway/directions/directions2.rds")
directions3 <- readRDS("../data/googleway/directions/directions3.rds")
```


```{r eval = FALSE, echo = FALSE, include = FALSE }
## reverse-engineering the directinos results to give me back the random addresses :s

# ## each of directions1, 2 & 3 
# 
# rand <- lapply( directions1, function(x) {
#   legs <- googleway::direction_legs( x )
#   data.frame(
#     address = legs$start_address
#     , lat = legs$start_location$lat
#     , lon = legs$start_location$lng
#   )
# })
# 
# df_random <- do.call( rbind, rand )
# 
# sf_random <- sf::st_as_sf( df_random, coords = c("lon", "lat"))
# 
# sf::st_crs( sf_random ) <- sf::st_crs( basicDemographicsVIC )
# 
# sf_random <- sf::st_join(
#   x = sf_random
#   , y = basicDemographicsVIC[, c("POA_CODE", "POA_CODE16")]
#   , left = FALSE
# ) 
# 
# # sf_postcodes <- sf::st_join(
# #   x = basicDemographicsVIC
# #   , y = sf_random[, "geometry"]
# #   , left = FALSE
# # )
# 
# sf::st_geometry( sf_random ) <- NULL
# 
# df <- merge(
#   x = unique( df_random )
#   , y = unique( sf_random )
#   , by = c("address")
# )
# 
# saveRDS(df_random, "../data/googleway/randomaddresses/df_random.rds")

```

The route geometry returned from the API comes in the form of an [encoded polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm).  

```{r}
substr( googleway::direction_polyline( directions1[[1]] ), 1, 100 )
```

We can convert this back into coordinates using the `googlePolylines` library, for example

```{r}
pl <- googleway::direction_polyline( directions1[[1]] )

head( googlePolylines::decode( pl )[[1]] )
```

However, `googleway` and `mapdeck` both support plotting these polylines directly, so we can avoid this step and just use the polylines. We also get the distance and time on the routes in the API query results. 

```{r}

get_distance <- function(x) {
  googleway::direction_legs(x)[["distance"]][["value"]]
}
get_duration <- function(x) {
  googleway::direction_legs(x)[["duration"]][["value"]]
}

format_directions <- function( directions ) {
  secs <- sapply( directions, get_duration )
  dist <- sapply( directions, get_distance )
  data.frame(
    polyline = sapply( directions, googleway::direction_polyline )
    , distance_m = dist
    , duration_s = secs
    , duration_m = round( secs / 60, 2 )
    , stringsAsFactors = FALSE
  )
}

df_directions1 <- format_directions( directions1 )
df_directions2 <- format_directions( directions2 )
df_directions3 <- format_directions( directions3 )

```

Now we have three data.frames, each containing the directions, distance, times and route for 10,000 random addresses to a rehab center. 

```{r, eval = FALSE}

mapdeck(
  style = mapdeck_style("light")
  , location = c(145, -37.9)
  , zoom = 10
) %>%
  add_scatterplot(
    data = df_rehab[1, ]
    , lon = "lon", lat = "lat"
    , radius = 200
    , update_view = F
  ) %>%
  add_path(
    data = df_directions1
    , polyline = "polyline"
    , stroke_colour = "duration_m"
    , stroke_opacity = 200
    , stroke_width = 35
    , legend = T
    , legend_options = list( title = "Duration (minutes) ")
    , update_view = F
    , palette = "plasma"
  )

```

![](./directions_rehab1_mapdeck.png)

We can extract the step-b-step guide, including times and locatinos, to get the 'time to destination' for each step.

```{r}
ttd <- googleway::direction_steps( directions1[[1]] )
total_time <- get_duration( directions1[[1]] )

## calculate time remaining at every step
ttd_duration <- ttd$duration
ttd_duration$total_time <- cumsum( ttd_duration$value )
ttd_duration$time_remaining <- total_time - ttd_duration$total_time

## get the coordinates for every step
ttd_duration <- cbind( ttd$start_location, ttd_duration )
ttd_duration
```

Doing this for each of the 30,000 directions gives us the time to the rehab centres for many points on the route, not just the origin. 

```{r}
time_to_destination <- function( direction ) {
  ttd <- googleway::direction_steps( direction )
  total_time <- get_duration( direction )

  ## calculate time remaining at every step
  ttd_duration <- ttd$duration
  ttd_duration$total_time <- cumsum( ttd_duration$value )
  ttd_duration$time_remaining <- total_time - ttd_duration$total_time
  
  ## get the coordinates for every step
  ttd_duration <- cbind( ttd$start_location, ttd_duration )
  ttd_duration
}

lst_times <- lapply( directions1, time_to_destination )
df_times1 <- do.call(rbind, lst_times)

lst_times <- lapply( directions2, time_to_destination )
df_times2 <- do.call(rbind, lst_times)

lst_times <- lapply( directions3, time_to_destination )
df_times3 <- do.call(rbind, lst_times)
```

This now gives us `r format( nrow( df_times1 ) * 3, big.mark=",")` random addresses to each of the three rehab centres. 

This plot shows the average times to `r googleway::geocode_address( RehabLocations[[1]] )` for `r nrow( df_times1 )` addresses. The height and colour of hexagons represent the average time to the rehab centre.

```{r, eval = FALSE, echo = FALSE, include = FALSE}

mapdeck() %>%
  add_scatterplot(
    data = df_times1
    , lat = "lat", lon = "lng"
    , fill_colour = "time_remaining"
    , stroke_width = 0
  )
```

```{r, eval = FALSE}
mapdeck() %>%
  add_hexagon(
    data = df_times1
    , lon = "lng", lat = "lat"
    , elevation = "time_remaining"
    , elevation_function = "average"
    , colour = "time_remaining"
    , colour_function = "average"
    , elevation_scale = 10
    , radius = 250
    , colour_range = colourvalues::colour_values(1:6, palette = "magma")
  )

```
![](./directions_rehab1_mapdeck_hexagons.png)

## Distances

While the Directions API gives us a lot of information, it only handles one direction at a time. If you want more (quantity and frequency), but less detailed results, you can query the distance API.

In this example we are querying the distances for the first ten random addresses.

```{r, eval = FALSE}

distance_matrix <- googleway::google_distance(
  origin = df_random[1:10, c("lat", "lon")]
  , destination = googleway::geocode_address( RehabLocations[[1]] )
)
saveRDS(distance_matrix, "../data/googleway/distances/distance_matrix.rds")
```

```{r echo = FALSE}
distance_matrix <- readRDS("../data/googleway/distances/distance_matrix.rds")
```

```{r, echo = FALSE, eval = FALSE}

# googleway::distance_elements( distance_matrix )
# 
# l <- lapply(1:10, function(x) {
#   directions1[[x]]$routes$legs[[1]]$distance
# })
# 
# do.call(rbind, l)

```


```{r}
distance_matrix
```


Both the distance and directions API allow you to specify the `departure_time`, so it's possible to query the time & distance for a given time of day. 


##  Estimate caseload per centre

From Google's API results we have the driving time to each of the rehab centres for the random addresses, so we know the proportion of each address from each postcode going to each serice centre


```{r}

head( df_random )

```




