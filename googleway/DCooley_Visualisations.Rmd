---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(googleway)
library(mapdeck)
library(viridisLite)
```




## Examples

- isochrones
- static & interactive
- shiny integration

# Interactive 

## googleway

```{r visualisationGoogleway} 
library(googleway)
set_key(read.dcf("~/Documents/.googleAPI", fields = "GOOGLE_MAP_KEY"), api = "map")
set_key(read.dcf("~/Documents/.googleAPI", fields = "GOOGLE_API_KEY"))
```

The `googleway` library provides access to Google Maps API, both for creating maps, and using the mapping services such as geocoding and searching for places. 

To use any of Google Map's services you will need an [API key](https://developers.google.com/maps/documentation/javascript/get-api-key).

Most mapping libraries in `R` support plotting shapes and layers. An advantage with `googleway` is access to their own traffic, bicycliing, transit and streetview layers. For example, to overlay traffic information call `add_traffic()`. 

```{r visualisationGooglewayTraffic}
google_map(location = c(-37.81, 144.97), zoom = 12) %>%
  add_traffic()
```

You can also add a **search bar** and use it to search for locations.

```{r visualisationGooglewaySearch}
google_map(location = c(-37.81, 144.97), zoom = 8, search_box = T)
```

**Markers** and **circles** can both be used to represent points on the map. In this example the stops of tram route 35 in Melbourne are represented as both circles and markers. It also shows how you add multiple layers on the map by using the 'pipe' (`%>%`) operator.

```{r visualisationGooglewayMarkers}
google_map( data = tram_stops ) %>%
  add_circles() %>%
  add_markers()
```

You can start to combine the services API with the maps by quering Google's directions service, and plotting the results. 

```{r visualisationGooglewayDirections}

directions <- google_directions(
  origin = "Melbourne Airport, Australia"
  , destination = "Monash University, Melbourne"
)

df <- data.frame(polyline = direction_polyline(directions) )

google_map() %>%
  add_polylines( data = df, polyline = "polyline")

```


A **choropleth** is made by plotting coloured polygons. In this example the polygons represent Statistical Areas (level 2) of melbourne, coloured according to the size of the area (km^2). The `info_window` argument lets you display content when the user clicks on one of the polygons. 

```{r visualisationGooglewayPolygon}
df <- melbourne
df$info <- paste0("SA2<br><b>",df$SA2_NAME,"</b>")

google_map() %>%
  add_polygons(
    data = df, fill_colour = "AREASQKM", stroke_colour = "AREASQKM", 
    info_window = "info",
    palette = viridisLite::plasma
  )

```

You can draw your own shapes on the map using `add_drawing()`. This is particularly useful in an interactive environment (Shiny) as information about the shapes you draw are returned back to your R session. 

```{r visualisationGooglewayDrawing} 
google_map() %>%
  add_drawing()
```

---


## Mapdeck

```{r visualisationMapdeck}
library(mapdeck)
set_token(read.dcf("~/Documents/.googleAPI", fields = "MAPBOX"))
```

The `mapdeck` library provides access to Uber's `Deck.gl` framework, and uses `Mapbox GL` as the mapping layer. Deck.gl's use of WebGL enables it to render large datasets (up to millions of points) quickly. It also provides a '2.5d' perspective of data, where the user can tilt, drag and rotate the map (as well as pan and zoom), and view data 'extruded' to give a perspective of height. 

To use Mapbox (through mapdeck) you will need an [access token](https://www.mapbox.com/help/how-access-tokens-work/)

This **choropleth** is showing the same data as in the `googelway` choropleth example, but a random 'elevation' value is added to show the data extruded from the map. While elevation provides a nice visual effect, care has to be taken to ensure it is meaningful and that users are interpreting the 'height' in the correct way (as opposed to the volume of the area). 


```{r mapdeckExtrudedExample}

df <- melbourne
df$elevation <- sample(100:5000, size = nrow(df))
df$info <- paste0("SA2<br><b>",df$SA2_NAME,"</b>")

mapdeck(style = mapdeck_style('dark') , location = c(145, -37.8) 
        ,pitch = 45, zoom = 10) %>%
  add_polygon(
    data = df, polyline = "geometry", layer = "polygon_layer", fill_colour = "AREASQKM",
    stroke_colour = "AREASQKM",elevation = "elevation", stroke_width = 0, tooltip = 'info',
    palette = viridisLite::plasma )

```


lines

```{r}
mapdeck(
  style = 'mapbox://styles/mapbox/dark-v9'
  , location = c(145, -37.8)
  , zoom = 10) %>%
  add_path(
    data = roads
    , stroke_colour = "RIGHT_LOC"
    , layer_id = "path_layer"
    , tooltip = "ROAD_NAME"
  )
```


## Shiny

All the interactive maps listed are built using the [`htmlwidgets`](https://www.htmlwidgets.org/) framework. Which is natively supported inside [`Shiny`](https://shiny.rstudio.com/) applications. This means you can include the maps in an interactive dashboard.

```{r visualisationShinyExample}


```