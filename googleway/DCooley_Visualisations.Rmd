---
title: "googleway and mapdeck"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(mapdeck)
library(googleway)
```


```{r visualisationGoogleway} 
set_key(read.dcf("~/Documents/.googleAPI", fields = "GOOGLE_MAP_KEY"), api = "map")
set_key(read.dcf("~/Documents/.googleAPI", fields = "GOOGLE_API_KEY"))
set_token( read.dcf("~/Documents/.googleAPI", fields = "MAPBOX" ) )
```

The `googleway` library provides access to Google Maps API, both for creating maps, and using the mapping services such as geocoding, direction and route finding, and searching for places. 

To use any of Google Map's services you will need an [API key](https://developers.google.com/maps/documentation/javascript/get-api-key).

## Geocoding

The geocoding API will take as input an address, or search term, and return various pieces of information. For example, here we are querying the API for three rehab centre addresses.

```{r, eval = FALSE}
rehab_addresses <- c(
  DandenongHospital = "Dandenong Hospital, Dandenong VIC 3175, Australia",
  CaseyHospital = "62-70 Kangan Dr, Berwick VIC 3806, Australia",
  KingstonHospital = "The Kingston Centre, Heatherton VIC 3202, Australia"
  )

RehabLocations <- lapply(rehab_addresses, googleway::google_geocode)
#saveRDS(RehabLocations, file = "../data/googleway/RehabLocations_googleway.rds")
```

```{r, eval = TRUE, echo = FALSE}
RehabLocations <- readRDS("../data/googleway/RehabLocations_googleway.rds")
```

From the results we can extract various pieces of information, such as the formatted address, the type of place, and the coordinates.

```{r}
RehabLocations[[1]][["results"]][["formatted_address"]]
RehabLocations[[1]][["results"]][["address_components"]]
RehabLocations[[1]][["results"]][["geometry"]][["location"]]
```


## Directions



We have 56,000 random addresses, and 3 rehab centres. This makes `r 56000 * 3` direction queries. 

Google charges 0.005 USD per query, but gives you $200 credit each month.

Therefore, we get `r 200 / 0.005` queries credited per month. 

To stay within limits, and have enough spare, I'm going to sample 10,000 of those random addresses for each rehab centre, and query the API for the directions from those addresses to the rehab centres. 


```{r}

## formatting the geocoded rehab centres into a data.frame
lst <- lapply( RehabLocations, function(x) {
  coords <- googleway::geocode_coordinates(x)
  data.frame(
    formatted_address = googleway::geocode_address(x),
    lat = coords[["lat"]],
    lon = coords[["lng"]]
    )
})

df_rehab <- do.call(rbind, lst)
rm(lst)
#df_rehab
```


To find the directions we need to query one route at a time. We can do this in an `lapply`. 

As this takes a while we are saving the results of each query to file at each iteration. Each result is in JSON, so we are saving the raw JSON.

```{r, eval = FALSE, echo = TRUE, include = TRUE}

set.seed(12345)
r <- 1:nrow(df)
r1 <- sample(r, size = 10000)
r2 <- sample(r, size = 10000)
r3 <- sample(r, size = 10000)

res1 <- lapply(r1, function(x) {
  js <- googleway::google_directions(
    origin = as.numeric( df_rehab[x, c("lat", "lon")] )
    , destination = as.numeric( sf::st_coordinates( RehabLocations[1, "geometry"] )[, c("Y","X")] )
    , simplify = F
  )
  js <- paste0(js, collapse = "")
  js <- gsub(" ","",js)
  fn <- paste0("../data/googleway/directions_queries/rehab1/",x,"_results.json")
  f <- file(fn)
  writeLines(js, f)
  close(f)
  return( js )
})

res2 <- lapply(r2, function(x) {
  js <- googleway::google_directions(
    origin = as.numeric( df_rehab[x, c("lat", "lon")] )
    , destination = as.numeric( sf::st_coordinates( RehabLocations[2, "geometry"] )[, c("Y","X")] )
  )
  js <- paste0(js, collapse = "")
  js <- gsub(" ","",js)
  fn <- paste0("../data/googleway/directions_queries/rehab2/",x,"_results.json")
  f <- file(fn)
  writeLines(js, f)
  close(f)
  return( js )
})

res3 <- lapply(r3, function(x) {
  js <- googleway::google_directions(
    origin = as.numeric( df_rehab[x, c("lat", "lon")] )
    , destination = as.numeric( sf::st_coordinates( RehabLocations[3, "geometry"] )[, c("Y","X")] )
  )
    js <- paste0(js, collapse = "")
  js <- gsub(" ","",js)
  fn <- paste0("../data/googleway/directions_queries/rehab3/",x,"_results.json")
  f <- file(fn)
  writeLines(js, f)
  close(f)
  return( js )
})

```

Now we have all the results of the directions query saved we can read them back into the R session

```{r, echo = TRUE, include = FALSE, eval = FALSE}

get_directions <- function(rehab) {
  path <- "~/Documents/github/GeospatialStroke/data/googleway/directions_queries"
  lst_files <- list.files(path = paste0(path, "/rehab1/") )
  files <- paste0(path, "/rehab1/", lst_files)

  return(
    lapply( files, jsonlite::fromJSON )
  )
}

directions1 <- get_directions( "/rehab1/")
directions2 <- get_directions( "/rehab2/")
directions3 <- get_directions( "/rehab3/")
```

```{r echo = FALSE, include = FALSE, eval = FALSE}
saveRDS(directions1, file = "../data/googleway/directions/directions1.rds")
saveRDS(directions2, file = "../data/googleway/directions/directions2.rds")
saveRDS(directions3, file = "../data/googleway/directions/directions3.rds")

```

```{r}
directions1 <- readRDS("../data/googleway/directions/directions1.rds")
directions2 <- readRDS("../data/googleway/directions/directions2.rds")
directions3 <- readRDS("../data/googleway/directions/directions3.rds")
```

The route geometry returned from the API comes in the form of an [encoded polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm).  

```{r}
substr( googleway::direction_polyline( directions1[[1]] ), 1, 100 )
```

We can convert this back into coordinates using the `googlePolylines` library, for example

```{r}
pl <- googleway::direction_polyline( directions1[[1]] )

head( googlePolylines::decode( pl )[[1]] )
```

However, `googleway` and `mapdeck` both support plotting these polylines directly, so we can avoid this step and just use the polylines. We can also get the distance and time on the routes. 

```{r}

get_distance <- function(x) {
  googleway::direction_legs(x)[["distance"]][["value"]]
}
get_duration <- function(x) {
  googleway::direction_legs(x)[["duration"]][["value"]]
}

format_directions <- function( directions ) {
  secs <- sapply( directions, get_duration )
  dist <- sapply( directions, get_distance )
  data.frame(
    polyline = sapply( directions, googleway::direction_polyline )
    , distance_m = dist
    , duration_s = secs
    , duration_m = round( secs / 60, 2 )
    , stringsAsFactors = FALSE
  )
}

df_directions1 <- format_directions( directions1 )
df_directions2 <- format_directions( directions2 )
df_directions3 <- format_directions( directions3 )

```

Now we have three data.frames, 

```{r, eval = FALSE}

mapdeck(
  style = mapdeck_style("light")
  , location = c(145, -37.9)
  , zoom = 10
) %>%
  add_scatterplot(
    data = df_rehab[1, ]
    , lon = "lon", lat = "lat"
    , radius = 200
    , update_view = F
  ) %>%
  add_path(
    data = df_directions1
    , polyline = "polyline"
    , stroke_colour = "duration_m"
    , stroke_opacity = 200
    , stroke_width = 35
    , legend = T
    , legend_options = list( title = "Duration (minutes) ")
    , update_view = F
    , palette = "plasma"
  )

```

![](./directions_rehab1_mapdeck.png)

The directions API also gives a step-by-step guide on the route, including times and locations at each turn. We can extract this data and get the 'time to destination' for each step

```{r}
ttd <- googleway::direction_steps( directions1[[1]] )
total_time <- get_duration( directions1[[1]] )

## calculate time remaining at every step
ttd_duration <- ttd$duration
ttd_duration$total_time <- cumsum( ttd_duration$value )
ttd_duration$time_remaining <- total_time - ttd_duration$total_time

## get the coordinates for every step
ttd_duration <- cbind( ttd$start_location, ttd_duration )
ttd_duration
```

We can do this for every direction, to give us the time to the rehab centres for many points on the route, not just the origin

```{r}
time_to_destination <- function( direction ) {
  ttd <- googleway::direction_steps( direction )
  total_time <- get_duration( direction )

  ## calculate time remaining at every step
  ttd_duration <- ttd$duration
  ttd_duration$total_time <- cumsum( ttd_duration$value )
  ttd_duration$time_remaining <- total_time - ttd_duration$total_time
  
  ## get the coordinates for every step
  ttd_duration <- cbind( ttd$start_location, ttd_duration )
  ttd_duration
}

lst_times <- lapply( directions1, time_to_destination )
df_times <- do.call(rbind, lst_times)
```

Now we can plot the time to the rehab centre for `r nrow(df_times)` coordinates. In this plot, the height and colour of hexagons represent the time to the rehab centre

```{r, eval = FALSE, echo = FALSE, include = FALSE}

mapdeck() %>%
  add_scatterplot(
    data = df_times
    , lat = "lat", lon = "lng"
    , fill_colour = "time_remaining"
    , stroke_width = 0
  )
```

```{r, eval = FALSE}
mapdeck() %>%
  add_hexagon(
    data = df_times
    , lon = "lng", lat = "lat"
    , elevation = "time_remaining"
    , elevation_function = "average"
    , colour = "time_remaining"
    , colour_function = "average"
    , elevation_scale = 10
    , radius = 250
    , colour_range = colourvalues::colour_values(1:6, palette = "plasma")
  )

```
![](./directions_rehab1_mapdeck_hexagons.png)
